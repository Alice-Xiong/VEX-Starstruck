#pragma config(Sensor, in1,    MBAL,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           extrarightarm, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           clawleft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontrightwheel, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           frontleftwheel, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           backleftwheel, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           backrightwheel, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           bottomleft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           bottomright,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           clawright,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          extraleftarm,  tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


#define Arm_High 3350
#define Arm_Mid 2500
#define Arm_Low 1563
#define Arm_Score 4150

int targetarmPosition = 0;
int armTaskEnable = 0;
task armTask()
{
	targetarmPosition = SensorValue[MBAL];
	while(true)
	{
		if(armTaskEnable == 1)
		{
			int error = targetarmPosition - SensorValue[MBAL];
			motor[extrarightarm]= motor[extraleftarm]= motor[bottomright]= motor[bottomleft] = error*0.6;
		}
	}
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	motor[backleftwheel] = motor[frontleftwheel]= motor[frontrightwheel] = motor[backrightwheel] = -127;
  wait1Msec(800);

  motor[extraleftarm] = motor[extrarightarm] = motor[bottomleft] = motor[bottomright] = 127;
  wait1Msec(700);

	motor[clawleft] = motor[clawright] = 127;
	wait1Msec(700);

	motor[clawleft] = motor[clawright] = 0;
	wait1Msec(100);

	motor[backleftwheel] = motor[frontleftwheel]= motor[frontrightwheel] = motor[backrightwheel] = -127;
  wait1Msec(700);

  motor[extraleftarm] = motor[extrarightarm] = motor[bottomleft] = motor[bottomright] = 127;
  wait1Msec(400);

  motor[backleftwheel] = 0;
  motor[backrightwheel] = 0;
  motor[frontleftwheel] = 0;
  motor[frontrightwheel] = 0;
  wait1Msec(50);

  motor[extraleftarm] = motor[extrarightarm] = motor[bottomleft] = motor[bottomright] = -127;
  wait1Msec(200);

  motor[extraleftarm] = motor[extrarightarm] = motor[bottomleft] = motor[bottomright] = 0;
  wait1Msec(200);
  }

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	startTask(armTask);

	bool armIsMoving = false;

	while (true)
  {
		motor[frontrightwheel] = vexRT[Ch2] - vexRT[Ch1];
		motor[frontleftwheel] = vexRT[Ch2] + vexRT[Ch1];
		motor[backrightwheel] = vexRT[Ch2] - vexRT[Ch1];
		motor[backleftwheel] = vexRT[Ch2] + vexRT[Ch1];


		if (vexRT[Btn6U] == 1)
			motor[clawleft]= motor[clawright] = 127;
		else if(vexRT[Btn6D] == 1)
			motor[clawleft]= motor[clawright] = -127;
		else
			motor[clawleft]= motor[clawright] = 0;

		if(vexRT[Btn8D] == 1 || vexRT[Btn7D] == 1)
		{
			armTaskEnable = 1;
			targetarmPosition = Arm_Low;
		}

		if(vexRT[Btn8U] == 1 || vexRT[Btn7U] == 1)
		{
			armTaskEnable = 1;
			targetarmPosition = Arm_Mid;
		}

		if (vexRT[Btn5U] == 1)
		{
			armIsMoving = true;
			armTaskEnable = 0;
			motor[extrarightarm]= motor[extraleftarm]= motor[bottomright]= motor[bottomleft] = 127;
		}
		else if (vexRT[Btn5D] == 1)
		{
			armIsMoving = true;
			armTaskEnable = 0;
			motor[extrarightarm]= motor[extraleftarm]= motor[bottomright]= motor[bottomleft] = -127;
		}
		else if(armIsMoving == true)
		{
			armIsMoving = false;
			targetarmPosition = SensorValue[MBAL];
			armTaskEnable = 1;
		}
	}
}
